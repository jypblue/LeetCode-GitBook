{"meta":{"title":"虾米爱吃鱼","subtitle":"码农，程序猿，前端工程师","description":null,"author":"Jachin","url":"http://jypblue.github.io"},"pages":[{"title":"about","date":"2015-12-17T10:18:45.000Z","updated":"2016-06-27T08:36:22.000Z","comments":true,"path":"about/index.html","permalink":"http://jypblue.github.io/about/index.html","excerpt":"","text":""}],"posts":[{"title":"2. Add Two Numbers","slug":"2. Add Two Numbers","date":"2016-06-28T14:47:58.000Z","updated":"2016-08-03T06:02:33.000Z","comments":true,"path":"2016/06/28/2. Add Two Numbers/","link":"","permalink":"http://jypblue.github.io/2016/06/28/2. Add Two Numbers/","excerpt":"","text":"更多我的LeetCode文章，请移步https://www.gitbook.com/book/jypblue/leetcode/details 2. Add Two NumbersYou are given two linked lists representing two non-negative numbers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. 12Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)Output: 7 -&gt; 0 -&gt; 8 题意您有两个表示两个非负数字的链表。这些数字以相反的顺序存储，每个节点都包含一个数字。相加两个数字，并将其作为链接列表返回。 思路 新建一个ListNode作为根节点 分成4种可能出现的情况：1.l1,l2都为空；2.l1,l2都不为空；3.l1不为空，l2为空；4.l2不为空l1为空，每种情况的相加进位 如果最后一位再进位，接点在多添加一个 返回根接点之后的ListNode Js实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** * Definition for singly-linked list. * function ListNode(val) &#123; * this.val = val; * this.next = null; * &#125; *//** * @param &#123;ListNode&#125; l1 * @param &#123;ListNode&#125; l2 * @return &#123;ListNode&#125; */var addTwoNumbers = function(l1, l2) &#123; if (l1 === null &amp;&amp; l2 === null) &#123; return null; &#125; //新建一个ListNode作为根节点 let node = new ListNode(0); let point = node; let val = 0; //当l1和l2都不为空得时候，求得各个节点的值 while (l1 !== null &amp;&amp; l2 !== null) &#123; let sum = val + l1.val + l2.val; point.next = new ListNode(sum % 10); val = Math.floor(sum / 10); l1 = l1.next; l2 = l2.next; point = point.next; &#125; //当l1不为空，l2为空得时候 while (l1 !== null) &#123; let sum = val + l1.val; point.next = new ListNode(sum % 10); val = Math.floor(sum / 10); l1 = l1.next; point = point.next; &#125; //当l2不为空，l1为空的时候 while (l2 !== null) &#123; let sum = val + l2.val; point.next = new ListNode(sum % 10); val = Math.floor(sum / 10); l2 = l2.next; point = point.next; &#125; //最后一位如果进一位 if (val !== 0) &#123; point.next = new ListNode(val); point = point.next; &#125; return node.next;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://jypblue.github.io/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://jypblue.github.io/tags/LeetCode/"}]},{"title":"Webpack构建前端工程项目","slug":"Webpack构建前端工程项目","date":"2016-06-27T09:25:36.000Z","updated":"2016-08-03T06:06:39.000Z","comments":true,"path":"2016/06/27/Webpack构建前端工程项目/","link":"","permalink":"http://jypblue.github.io/2016/06/27/Webpack构建前端工程项目/","excerpt":"","text":"最近开始学习React/ReactNative，需要动手实践，按照官网提供的方式可以运行React的简单小例子，但是很不方便，就想可不可以使用工具搭建一个前端的React-ES6-Sass的开发环境方便开发运行，因此想到了现在很火的webpack。之前自己一直都用的是gulp来构建sass和es6，所以打算研究一下webpack，利用gulp和webpack结合起来，用来管理与打包。先上项目地址：https://github.com/jypblue/webpack-scheme 一、项目准备1. webpack初认识webpack自从出现就很火，因为他可以管理前端的各种资源，查看了一下它的官网，发现不太容易上手，所以就在网上找了两篇关于webpack的入门教程学习： https://github.com/ruanyf/webpack-demos https://github.com/petehunt/webpack-howto/blob/master/README-zh.md 推荐先学习这两篇入门教程，做到可以入门使用webpack后，再去官网查看文档学习。 2. koa学习因为是需要搭建一个工程项目的开发环境，所以需要本地构建服务器，感谢node，让js的生态越来越好。现有的前端工具都是建立在node环境上。打算利用koa框架本地构建服务器，所以需要学习koa的使用，于是去koa官网学习了koa简单的基本用法，贴一下koa官网的地址koa中文网;当然使用express框架也是ok的，只是觉得打算构建es6的开发环境，所以就打算使用面向未来的koa框架 3. gulp当然gulp的使用也得知道，因为需要用它来做任务管理，这里就不详细讲了，gulp官网已经讲得很好了，贴一下gulp官网地址：gulp中文网 前端开发环境搭建1. 项目目录结构123456789101112131415161718192021222324252627├── gulpfile.js # gulp任务配置├── package.json # 项目配置├── README.md # 项目说明├── server # 本地server│ ├── app.js # 本地server入口│ ├── routes/ # 后端路由文件夹│ ├── mock # 后端模拟数据文件夹│ └── views/ # 后端views文件夹├── src # 源码目录│ ├── XXX.html # XXX入口文件│ ├── css/ # css文件夹│ ├── fonts/ # 字体文件│ ├── img/ # 图片文件夹│ ├── js # js&amp;jsx文件夹│ │ ├── XXX.js # XXX页面入口js/jsx文件│ │ ├── action/ # Action Creators文件夹：存放可以触发的action函数│ │ ├── components/ # React展示组件文件夹│ │ ├── constants/ # Action 大写字符串描述事件│ │ ├── containers/ # 容器文件夹：存放容器组件│ │ ├── reducers/ # reducers文件夹：存放action的处理器reducers│ │ ├── store/ # store文件夹│ │ └── utils/ # 前端路由文件夹│ ├── scss/ # scss文件夹│ ├── libsPath.json # 手动配置某些模块的路径，可以加快webpack的编译速度├── webpack-build.config.js # webpack基本配置├── webpack.config.js # 正式环境webpack配置入口└── webpack-dev.config.js # 开发环境webpack配置入口 目前server部分还没有添加，只是把目录建好了，后续会把server中充分利用koa框架的代码添加进去，包括连接mongodb等 2. 本地开发环境搭建1234567891011121314151617181920212223242526272829303132\"use strict\";//加载node模块let http = require('http');let path = require('path');let util = require('util');//加载koa框架模块let koa = require('koa');let router = require('koa-router')();let serve = require('koa-static');let open = require('open');//加载本地文件let pkg = require('../package.json');let env = process.argv[2] || process.env.NODE_ENV;let dev = 'production' !== env;let viewDir = debug ? 'src' : 'dist';let staticDir = path.resolve(__dirname, '../' + (dev ? 'src' : 'dist'));//加载routeslet routes = require('./routes/routes.js');//初始化let app = koa();//基本设定app.keys = [pkg.name, pkg.description];app.proxy = true;//使用路由routes(router, app, staticDir);app.use(router.routes());app = http.createServer(app.callback());app.listen(pkg.server.port, '127.0.0.1', () =&gt; &#123; let url = util.format('http://%s:%d', 'localhost', pkg.server.port); console.log('Listening at %s', url); open(url);&#125;); 运行node app.js 就启动了本地的webserver了，浏览器会自动新开一个页面list 3. webpack资源管理资源获取webpack中，可以把node_modules的路径添加到resolve search root 列表里面，这样就可以在项目中直接加载npm模块了 1let nodeModPath = path.resolve(__dirname, './node_modules'); 12345resolve: &#123; root: [srcDir, nodeModPath], alias: pathMap, extensions: ['', '.js', '.jsx', '.css', '.scss', '.tpl', '.png', '.jpg', '.jpeg'] &#125;, 这样在js文件中就可以利用ES6语法，查找到并加载模块引用进来 12import React from 'react';import &#123;render&#125; from 'react-dom'; 资源加载webpack加载各种资源是通过不同的插件来实现的，通过简单的配置参数就能做到： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546module: &#123; loaders: [ //图片 &#123; test: /\\.((woff2?|svg)(\\?v=[0-9]\\.[0-9]\\.[0-9]))|(woff2?|svg|jpe?g|png|gif|ico)$/, //url-loader图片小于10k自动转成dataUrl， //否则调用file-loader,参数直接传入 loaders: [ 'url?limit=10000&amp;name=img/[hash:8].[name].[ext]' ] &#125;, //字体 &#123; test: /\\.((ttf|eot|woff|svg)(\\?t=[0-9]\\.[0-9]\\.[0-9]))|(ttf|eot|woff|svg)\\??.*$/, loader: 'url?limit=10000&amp;name=fonts/[name].[ext]' &#125;, //模板 &#123; test: /\\.(tpl|ejs)$/, loader: 'ejs' &#125;, //css &#123; test: /\\.css$/, loader: cssLoader &#125;, //sass &#123; test: /\\.(scss|sass)$/, loader: sassLoader &#125;, //less &#123; test: /\\.less$/, loeader: lessLoader &#125;, //jsx &#123; test: /\\.js[x]$/, loader: ['babel-loader'], query: &#123; presets: ['es2015', 'react', 'stage-0'] &#125; &#125; ]&#125;, 上面配置了img,confront,template,css,sass,less,jsx等资源类型，因此项目中也能直接利用ES6语法或者commonJS语法require各种资源。 12345678//加载css资源import '../fonts/iconfont.css';require('../fonts/iconfont.css');//加载图片let d1 = require('../img/d1.jpg');//加载jsimport React from 'react';require('react'); 资源打包webpack有三个概念：模块（module）、入口文件（entry）、分块（chunk） 模块（module）:各种资源，如js,css,img,iconfont,svg,scss,less 入口（entry）:可以是一个或者多个资源合并，通过html的script标签引入 分块（chunk）:被entry所依赖的额外的代码块，可以包含一个或者多个文件 我们通过path,glob模块，获取到文件夹下得所有开发js文件作为入口文件地址及名称 12345678910let entries = (() =&gt; &#123; let jsDir = path.resolve(srcDir, 'js'); let entryFiles = glob.sync(jsDir + '/*.&#123;js,jsx&#125;'); let map = &#123;&#125;; entryFiles.forEach((filePath) =&gt; &#123; let filename = filePath.substring(filePath.lastIndexOf('\\/') + 1, filePath.lastIndexOf('.')); map[filename] = filePath; &#125;); return map;&#125;)(); 另外，webpack也支持资源异步加载，通过require.ensure()，将里面包裹的部分进行单独打包 1234require.ensure([], function(require) &#123; var toast = require('./components/Slider'); // todo ... &#125;); 资源热替换在webpack中，通过本地启动一个web-dev-server,来负责处理由webpack生成的静态资源请求，而webpack-dev-server是把所有资源存在内存中的。资源更新的时候chunk会改变，以此达到热替换。 webpack-dev-server集成到koa服务器中： 1234567891011121314// statementlet webpackDevMiddleware = require('koa-webpack-dev-middleware');let webpack = require('webpack');let webpackConf = require('../webpack-dev.config.js');let compiler = webpack(webpackConf);//使用koa做服务器配置koa-webpack-dev-middlewareapp.use(webpackDevMiddleware(compiler, webpackConf.devServer));//配置webpack-hot-middleware实现hot module replacelet hotMiddleware = require('webpack-hot-middleware')(compiler);//koa 对webpack-hot-middleware做适配app.use(function*(next) &#123; yield hotMiddleware.bind(null, this.req, this.res); yield next;&#125;); webpack中也做相应的配置： 12345678910((entry) =&gt; &#123; for (let key of Object.keys(entry)) &#123; // statement if (!Array.isArray(entry[key])) &#123; entry[key] = Array.of(entry[key]); &#125; entry[key].push('webpack-hot-middleware/client?reload=true'); &#125;&#125;)(config.entry);config.plugins.push(new webpack.HotModuleReplacementPlugin()); 资源公用部分抽离使用CommonsChunkPlugin插件将指定的chunks的公共模块提取合并在一起 123456789plugins: [ // //可以自主添加提取公共部分，拆分包以免包过大 // new CommonsChunkPlugin(&#123; // &#125;), new CommonsChunkPlugin(&#123; name: 'common-slider', chunks: ['rSlider', 'todo'] &#125;) ] 4. gulp管理任务我们通过webpack良好的构建了资源的引用打包工作，那么gulp就用来管理任务的执行，本地新建gulpfile.js文件，添加eslint语法检测的任务，webpack构建的任务，以及clean重新构建生成的任务 12345678910111213141516171819202122232425262728293031323334353637383940414243'use strict';let gulp = require('gulp');let webpack = require('webpack');let gulputil = require('gulp-util');// 加载webpack配置文件let webpackconf = require('./webpack.config.js');//js文件目录入口let src = process.cwd() + '/src';//文件发布版本let dist = process.cwd() + '/dist';//eslint checkgulp.task('lint', () =&gt; &#123; let eslint = require('gulp-eslint'); return gulp.src([ '!' + src + '/js/lib/**/*.js', src + '/js/**/*.js' ]) .pipe(eslint()) .pipe(eslint.format()) .pipe(eslint.failAfterError());&#125;);//clean distgulp.task('clean', ['lint'], () =&gt; &#123; let clean = require('gulp-clean'); return gulp.src(dist, &#123; read: true &#125;).pipe(clean());&#125;);//run webpackgulp.task('pack', ['clean'], (done) =&gt; &#123; //开发版本webpackdevconf,生产版本webpackconf //生成release版本时检查是否使用sass因为sass-loader有问题，所以最好还是原生css用于生产 webpack(webpackconf, (err, stats) =&gt; &#123; if (err) &#123; throw new gulputil.PluginError('webpack', err); &#125; gulputil.log('[webpack]', stats.toString(&#123; colors: true &#125;)); done(); &#125;)&#125;)gulp.task('default', ['pack']); 三、总结由此，我们搭建好了React、Es6、Sass的开发环境，可以高效的制作前端原型，做到事半功倍的书写前端代码。同时也练习了node,es6等前端技术。后续还会完善koa部分，希望工具后面可以将koa工程项目完全集成起来，组合使用，src部分则添加redux+react结合使用的例子。","categories":[{"name":"Tools","slug":"Tools","permalink":"http://jypblue.github.io/categories/Tools/"}],"tags":[{"name":"gulp","slug":"gulp","permalink":"http://jypblue.github.io/tags/gulp/"},{"name":"webpack","slug":"webpack","permalink":"http://jypblue.github.io/tags/webpack/"}]},{"title":"1. Two Sum","slug":"1. Two Sum","date":"2016-06-26T11:00:00.000Z","updated":"2016-08-03T06:02:23.000Z","comments":true,"path":"2016/06/26/1. Two Sum/","link":"","permalink":"http://jypblue.github.io/2016/06/26/1. Two Sum/","excerpt":"","text":"更多我的LeetCode文章，请移步https://www.gitbook.com/book/jypblue/leetcode/details 1. Two SumGiven an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution. Example:1234Given nums = [2, 7, 11, 15], target = 9,Because nums[0] + nums[1] = 2 + 7 = 9,return [0, 1]. 题意给定一个正整数数组，并设定一个目标值。如果数组中的两个数字相加可以与目标值相等，返回这两个数在该数组中的位置。 思路 将数组中的value 和 key 存储到一个Map中，value作为Map的key，key作为Map的value; 新建一个空得result返回数组，循环目标数组，用目标值减去数组中得每一个值，在剩于的数值中如果能在Map中找到对应的值，则这两个数满足条件; 比较两个数字的key值，按升序存入新建的result数组中. Js实现12345678910111213141516171819202122/** * @param &#123;number[]&#125; nums * @param &#123;number&#125; target * @return */let twoSum = function(nums, target) &#123; let result = [], n2 = null, idx = null; let map = new Map(); for(let i = 0; i &lt; nums.length; i++)&#123; map.set(nums[i],i); &#125; for(let i = 0; i &lt; nums.length - 1; i++) &#123; n2 = target - nums[i]; idx = map.get(n2); if(idx !== null &amp;&amp; idx &gt; i) &#123; result[0] = i; result[1] = idx; break; &#125; &#125; return result;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://jypblue.github.io/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://jypblue.github.io/tags/LeetCode/"}]},{"title":"Js排序算法","slug":"Js排序算法","date":"2016-04-25T03:15:46.000Z","updated":"2016-07-04T10:39:45.000Z","comments":true,"path":"2016/04/25/Js排序算法/","link":"","permalink":"http://jypblue.github.io/2016/04/25/Js排序算法/","excerpt":"","text":"虽然一般的前端开发，实际工作中应用到算法的情况比较少，但是呢不管是前端还是后端都是程序员，都应该对常用算法，数据结构有一定的了解及掌握，知道如何应用到自身所擅长的语言中，下面我将介绍一下常用排序算法有关原理，以及在Javascript语言的具体实现。 首先列一下各种排序算法的时间复杂度，空间复杂度及稳定性： 排序算法 平均时间复杂度 最坏时间复杂度 空间复杂度 稳定性 冒泡排序 O(n2) O(n2) O(1) 稳定 选择排序 O(n2) O(n2) O(1) 不稳定 插入排序 O(n2) O(n2) O(1) 稳定 快速排序 O(nlogn) O(n2) O(logn) 不稳定 归并排序 O(nlogn) O(nlogn) O(1) 稳定 堆排序 O(nlogn) O(nlogn) O(1) 不稳定 二叉树排序 O(nlogn) O(nlogn) O(n) 稳定 希尔排序 O(nlogn) O(n8)1 O(1) 不稳定 基数排序 O(logRB) O(logRB) O(n) 稳定 计数排序 O(n+k) O(n+k) O(n+k) 稳定 1.冒泡排序 算法原理 相邻的数据进行两两比较，较小的数放在前面，较大的数放在后面，循环一次下来，最小的数就在第一位了，第二次循环跑一次也一样，如此类推，直到所有的数据排序完成。 算法描述 1.比较相邻的元素。如果第一个比第二个大，就交换它们两个；2.对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；3.针对所有的元素重复以上的步骤，除了最后一个；4.重复步骤1~3，直到排序完成。 Js代码实现 1234567891011function bubbleSort(arr) &#123; var l = arr.length,j; for(var i = 0 ; i &lt; l ; i++)&#123; for(var j = 0;j &lt; l-i ; j++)&#123; if(arr[j] &lt; arr[j - i]) &#123; arr[j] = [ arr[j-1] , arr[j-1] = arr[j] ][0]; &#125; &#125; &#125; return arr;&#125; 2.选择排序 算法原理 在未排序的数组中找到最小（大）的元素，放在排序数组的起始位置。然后，从剩余未排序的数中继续查找最小（大）的元素，放到已排序的数的末尾。以此类推，直到所有元素均排序完毕。 算法描述 1.初始状态：无序区为R[1..n]，有序区为空；2.第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；3.n-1趟结束，数组有序化了。 Js代码实现 123456789101112131415function selectionSort(array) &#123; var min; var l = array.length;//缓存长度 for (var i = 0; i &lt; l; i++) &#123;//开始进行循环，一共循环l次，就可以找出l个元素了 min = i;//假设第一个为最小元素 for (var j = i + 1; j &lt; l; j++) &#123;//从第一个开始循环，遍历 if (array[min] &gt; array[j])//判断之后的是否比前面的小 min = j;//更新“最小”的下标 &#125; if (min != i) &#123;//这里因为是在同一个数组内进行操作，所以直接交换元素即可。比如数组第一项是i，那么我找出了最小元素为array[min],那么我就需要把这个min跟i交换。以此类推。 array[i]= [array[min],array[min]=array[i]][0];//交换元素 &#125; &#125; return array;&#125; 3.插入排序 算法原理 将数据分为两部分，有序部分与无序部分。一开始有序部分包含第一个元素，依次将无序部分的元素插入到有序部分，直到所有元素有序。 算法描述 1.从第一个元素开始，该元素可以认为已经被排序；2.取出下一个元素，在已经排序的元素序列中从后向前扫描；3.如果该元素（已排序）大于新元素，将该元素移到下一位置；4.重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；5.将新元素插入到该位置后；7.重复步骤2~5。 Js代码实现 12345678910111213function insertSort(arr) &#123; var temp,inner; for(var outer = 1;outer&lt;=arr.length - 1;outer++) &#123; temp = arr[outer]; inner = outer; while(inner &gt; 0 &amp;&amp; (arr[inner - 1 ] &gt;= temp)) &#123; arr[inner] = arr[inner - 1]; --inner; &#125; arr[inner] = temp; &#125; return arr;&#125; 3.2 二分插入排序 算法原理 在直接插入排序的基础上进行小改动，与直接插入排序算法最大的区别在于查找插入位置时使用的是二分查找的方式，在速度上有一定提升。 算法描述 1.从第一个元素开始，该元素可以认为已经被排序；2.取出下一个元素，在已经排序的元素序列中二分查找到第一个比它大的数的位置；3.将新元素插入到该位置后；4.重复上述两步。 Js代码实现 123456789101112131415161718function binaryInsertionSort(array) &#123; for (var i = 1; i &lt; array.length; i++) &#123; var key = array[i], left = 0, right = i - 1; while (left &lt;= right) &#123; var middle = parseInt((left + right) / 2); if (key &lt; array[middle]) &#123; right = middle - 1; &#125; else &#123; left = middle + 1; &#125; &#125; for (var j = i - 1; j &gt;= left; j--) &#123; array[j + 1] = array[j]; &#125; array[left] = key; &#125; return array;&#125; 4.快速排序 算法原理 快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。通过一次排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序递归进行。最后达到整个数据变成有序序列。 算法描述 1.从数列中挑出一个元素，称为 “基准”（pivot）；2.重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；3.递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序 Js代码实现 123456789101112131415161718192021222324252627282930313233343536//方法一function quickSort(array, left, right) &#123; if(array.length ==0) &#123; return []; &#125; if (left &lt; right) &#123; var x = array[right], i = left - 1, temp; for (var j = left; j &lt;= right; j++) &#123; if (array[j] &lt;= x) &#123; i++; temp = array[i]; array[i] = array[j]; array[j] = temp; &#125; &#125; quickSort(array, left, i - 1); quickSort(array, i + 1, right); &#125;;&#125; //方法二function quickSort(arr) &#123; if(arr.length ==0) &#123; return []; &#125; var left =[]; var right = []; var pivot = arr[0]; for(var i = 1;i &lt; arr.length;i++)&#123; if(arr[i] &lt; pivot)&#123; left.push(arr[i]); &#125; else &#123; right.push(arr[i]); &#125; &#125; return quickSort(left).concat(pivot,quickSort(right));&#125; 5.归并排序 算法原理 （假设序列共有n个元素）将序列每相邻两个数字进行归并操作（merge)，形成floor(n/2)个序列，排序后每个序列包含两个元素。将上述序列再次归并，形成floor(n/4)个序列，每个序列包含四个元素。重复以上步骤，直到所有元素排序完毕。 算法描述 1.把长度为n的输入序列分成两个长度为n/2的子序列；2.对这两个子序列分别采用归并排序；3.将两个排序好的子序列合并成一个最终的排序序列 Js代码实现 123456789101112131415161718192021222324252627function mergeSort(array, p, r) &#123; if (p &lt; r) &#123; var q = Math.floor((p + r) / 2); mergeSort(array, p, q); mergeSort(array, q + 1, r); merge(array, p, q, r); &#125;&#125;function merge(array, p, q, r) &#123; var n1 = q - p + 1, n2 = r - q, left = [], right = [], m = n = 0; for (var i = 0; i &lt; n1; i++) &#123; left[i] = array[p + i]; &#125; for (var j = 0; j &lt; n2; j++) &#123; right[j] = array[q + 1 + j]; &#125; left[n1] = right[n2] = Number.MAX_VALUE; for (var k = p; k &lt;= r; k++) &#123; if (left[m] &lt;= right[n]) &#123; array[k] = left[m]; m++; &#125; else &#123; array[k] = right[n]; n++; &#125; &#125;&#125; 6.堆排序 算法原理 堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。 算法描述 1.将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区；2.将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]&lt;=R[n]；3.由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成 Js代码实现 12345678910111213141516171819202122232425262728293031323334353637383940414243/*方法说明：堆排序@param array 待排序数组*/ function heapSort(array) &#123; if (Object.prototype.toString.call(array).slice(8, -1) === 'Array') &#123; //建堆 var heapSize = array.length, temp; for (var i = Math.floor(heapSize / 2); i &gt;= 0; i--) &#123; heapify(array, i, heapSize); &#125; //堆排序 for (var j = heapSize - 1; j &gt;= 1; j--) &#123; temp = array[0]; array[0] = array[j]; array[j] = temp; heapify(array, 0, --heapSize); &#125; &#125; else &#123; return 'array is not an Array!'; &#125;&#125;/*方法说明：维护堆的性质@param arr 数组@param x 数组下标@param len 堆大小*/function heapify(arr, x, len) &#123; if (Object.prototype.toString.call(arr).slice(8, -1) === 'Array' &amp;&amp; typeof x === 'number') &#123; var l = 2 * x, r = 2 * x + 1, largest = x, temp; if (l &lt; len &amp;&amp; arr[l] &gt; arr[largest]) &#123; largest = l; &#125; if (r &lt; len &amp;&amp; arr[r] &gt; arr[largest]) &#123; largest = r; &#125; if (largest != x) &#123; temp = arr[x]; arr[x] = arr[largest]; arr[largest] = temp; heapify(arr, largest, len); &#125; &#125; else &#123; return 'arr is not an Array or x is not a number!'; &#125;&#125; 7.二叉树排序 算法原理 Js代码实现 12 8.希尔排序 算法原理 Js代码实现 12 9.基数排序 算法原理 Js代码实现 12 10.计数排序 算法原理 计数排序使用一个额外的数组C，其中第i个元素是待排序数组A中值等于i的元素的个数。然后根据数组C来将A中的元素排到正确的位置。它只能对整数进行排序。 算法描述 1.找出待排序的数组中最大和最小的元素；2.统计数组中每个值为i的元素出现的次数，存入数组C的第i项；3.对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）；4.反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1 Js代码实现 12345678910111213141516function countingSort(array) &#123; var len = array.length, B = [], C = [], min = max = array[0]; for (var i = 0; i &lt; len; i++) &#123; min = min &lt;= array[i] ? min : array[i]; max = max &gt;= array[i] ? max : array[i]; C[array[i]] = C[array[i]] ? C[array[i]] + 1 : 1; &#125; for (var j = min; j &lt; max; j++) &#123; C[j + 1] = (C[j + 1] || 0) + (C[j] || 0); &#125; for (var k = len - 1; k &gt;=0; k--) &#123; B[C[array[k]] - 1] = array[k]; C[array[k]]--; &#125; return B;&#125; 11.桶排序 算法原理 假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序）。 算法描述 1.设置一个定量的数组当作空桶；2.遍历输入数据，并且把数据一个一个放到对应的桶里去；3.对每个不是空的桶进行排序；4.从不是空的桶里把排好序的数据拼接起来。 Js代码实现 12345678910111213141516171819202122232425262728293031323334/*方法说明：桶排序@param array 数组@param num 桶的数量*/function bucketSort(array, num) &#123; if (array.length &lt;= 1) &#123; return array; &#125; var len = array.length, buckets = [], result = [], min = max = array[0], regex = '/^[1-9]+[0-9]*$/', space, n = 0; num = num || ((num &gt; 1 &amp;&amp; regex.test(num)) ? num : 10); for (var i = 1; i &lt; len; i++) &#123; min = min &lt;= array[i] ? min : array[i]; max = max &gt;= array[i] ? max : array[i]; &#125; space = (max - min + 1) / num; for (var j = 0; j &lt; len; j++) &#123; var index = Math.floor((array[j] - min) / space); if (buckets[index]) &#123; // 非空桶，插入排序 var k = buckets[index].length - 1; while (k &gt;= 0 &amp;&amp; buckets[index][k] &gt; array[j]) &#123; buckets[index][k + 1] = buckets[index][k]; k--; &#125; buckets[index][k + 1] = array[j]; &#125; else &#123; //空桶，初始化 buckets[index] = []; buckets[index].push(array[j]); &#125; &#125; while (n &lt; num) &#123; result = result.concat(buckets[n]); n++; &#125; return result;&#125;","categories":[{"name":"FrontEnd","slug":"FrontEnd","permalink":"http://jypblue.github.io/categories/FrontEnd/"}],"tags":[{"name":"algorithms","slug":"algorithms","permalink":"http://jypblue.github.io/tags/algorithms/"}]},{"title":"Gulp实现配置Es6及sass环境","slug":"Gulp实现配置Es6及sass环境","date":"2016-03-28T11:05:46.000Z","updated":"2016-06-21T07:51:29.000Z","comments":true,"path":"2016/03/28/Gulp实现配置Es6及sass环境/","link":"","permalink":"http://jypblue.github.io/2016/03/28/Gulp实现配置Es6及sass环境/","excerpt":"","text":"之前已经讲过如何全局安装gulp，以及如何在开发项目中安装gulp依赖，那么这篇作为上篇的补充，说一下利用gulp-babel及gulp-sass包配置Es6及Sass转Es5及css的任务环境。 1.安装所需gulp插件到指定的目录下执行 npm init这个时候会生成一个叫package.json的文件，然后执行 npm install gulp --save-dev会在package.json 里生成devDependencies对象，这个里面讲放入你所依赖的gulp插件,然后添加所需的各个插件。 以下就是一个pageage.json的例子 123456789101112131415161718&#123; \"name\": \"demo\", \"version\": \"0.0.0\", \"description\": \"\", \"main\": \"xxx.js\", \"scripts\": &#123; \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\" &#125;, \"author\": \"XXX\", \"license\": \"ISC\", \"devDependencies\": &#123; \"gulp-util\": \"*\", \"gulp\": \"*\", \"gulp-minify-css\": \"*\", \"gulp-uglify\": \"*\", \"gulp-concat\": \"*\" &#125;&#125; 我们在执行一次以下命令，我们所需要的插件就会加载下来 npm install 接下来我们还需要新建一个js文件 gulpfile.js最前面是加载gulp的插件，加载好插件之后，我们需要gulp帮我们执行任务. 12345678910111213141516171819202122// 加载插件var gulp = require('gulp'), gutil = require('gulp-util'), uglify = require('gulp-uglify'), concat = require('gulp-concat') minifycss = require('gulp-minify-css');/** * 注册一个任务 */gulp.task('concat', function() &#123; gulp.src(['./js/**/*.js', '!js/index.js']) .pipe(uglify()) .pipe(concat('all.min.js')) .pipe(gulp.dest('./build'));&#125;);gulp.task('default', ['concat']);gulp.task('watch', function() &#123; gulp.watch('./js/**/*.js', ['concat']);&#125;); 2.gulp的api只有简单的几个task方法task方法是用于定义一个具体任务的方法。如果需要执行任务，在终端执行gulp task-name。 gulp.task(name[, deps], fn) 第一个参数是任务的名字。 第二个参数是array类型，指在跑当前任务时，对其它任务的依赖。也就是要执行当前任务，会先执行这些依赖的任务。gulp.task(&#39;demo&#39;, [&#39;demo1&#39;, &#39;demo2&#39;], function(){ }); 这是在执行demo任务时，会先同时执行demo1 和 demo2任务 第三个参数是函数,指运行任务时，要执行的具体操作的内容. src方法是指定源文件的输入路径，pipe有点像是封闭的“流水线”，某个产品经过上一个工序处理后，就转入下一个工序去处理，直到完成。也就是将上一步的输出转化下一步的输入的中间者gulp.src(globs[, options]) 第一个参数是string或者array,指定源文件的路径，可以是单个路径，也可以是个路径数组。 app.js 指定具体文件 js/* 匹配 js 目录下所有的文件，不包括子文件夹 js/*.js 匹配 js 目录下所有的扩展名为 .js 的文件，不包括子文件夹 js/*/*.js 匹配 js 目录下第一层子文件夹里的扩展名为 .js 的文件 js/**/*.js 匹配 js 目录下所有文件夹层次下扩展名为 .js 的文件 !js/try.js 不包括 try.js 文件，在前五条文件匹配模式前加!，就忽略掉相应的文件 下面这个任务中,代表js目录下的所有js文件,但是不包括index.js这个文件 123456789/** * 注册一个任务 */gulp.task('concat', function() &#123; gulp.src(['./js/**/*.js', '!js/index.js']) .pipe(uglify()) .pipe(concat('all.min.js')) .pipe(gulp.dest('./build'));&#125;); dest方法是指定被处理完的文件的输出路径,像上面那样操作的话,最后文件的输出路径是build目录gulp.dest(path[, options]) path String 或 Function，指定输出文件的文件夹路径，可以是字符串，也可以是一个返回文件夹路径的函数。 options Object类型,两个属性 cwd mode options.cwd 类型：String，默认：process.cwd() 设置输出文件夹路径的相对路径，默认为当前脚本的工作目录的路径。 options.mode 类型：String，默认：0777 设置被创建文件夹的权限。 watch方法是用于监听文件变化，文件一修改就会执行指定的任务。gulp.watch(glob [, opts], tasks) or gulp.watch(glob [, opts, cb]) glob: String 或 Array，指定源文件的路径，可以是单个路径，也可以是个路径数组。路径匹配和上述gulp.src()方法路径匹配的模式一样 opts Object类型,4个属性 cwd mode debounceDelay interval tasks 类型：Array，监听到文件变化后，要被执行的任务的名字组成的数组. cd 类型：Function，回调函数。","categories":[{"name":"Tools","slug":"Tools","permalink":"http://jypblue.github.io/categories/Tools/"}],"tags":[{"name":"gulp","slug":"gulp","permalink":"http://jypblue.github.io/tags/gulp/"}]},{"title":"Gulp实现前端资源压缩","slug":"Gulp实现前端资源压缩","date":"2016-03-22T11:05:46.000Z","updated":"2016-06-21T07:55:32.000Z","comments":true,"path":"2016/03/22/Gulp实现前端资源压缩/","link":"","permalink":"http://jypblue.github.io/2016/03/22/Gulp实现前端资源压缩/","excerpt":"","text":"gulp安装gulp是构建在node环境上的，所以安装gulp之前首先是需要安装好node，安装node的话直接去官网下载自己需要的版本，点击安装即可。 1.全局安装gulp1npm install gulp -g 2.作为项目开发依赖中安装gulp1npm install gulp --save-dev 3.安装需要依赖的功能包模块12345npm install gulp-minify-css --save-devnpm install gulp-concat --save-devnpm install gulp-uglify --save-devnpm install gulp-rename --save-devnpm install gulp-jshint --save-dev 在项目根目录下创建一个名为gulpfile.js的文件新建gulpfile.js,编写压缩任务js代码 1234567891011121314151617181920212223242526272829303132var gulp = require('gulp'), minifycss = require('gulp-minify-css'), concat = require('gulp-concat'), uglify = require('gulp-uglify'), rename = require('gulp-rename'), jshint=require('gulp-jshint'); //语法检查 gulp.task('jshint', function () &#123; return gulp.src('js/*.js') .pipe(jshint()) .pipe(jshint.reporter('default')); &#125;); //压缩css gulp.task('minifycss', function() &#123; return gulp.src('css/*.css') //需要操作的文件 .pipe(rename(&#123;suffix: '.min'&#125;)) //rename压缩后的文件名 .pipe(minifycss()) //执行压缩 .pipe(gulp.dest('Css')); //输出文件夹 &#125;); //压缩，合并 js gulp.task('minifyjs', function() &#123; return gulp.src('js/*.js') //需要操作的文件 .pipe(concat('main.js')) //合并所有js到main.js .pipe(gulp.dest('js')) //输出到文件夹 .pipe(rename(&#123;suffix: '.min'&#125;)) //rename压缩后的文件名 .pipe(uglify()) //压缩 .pipe(gulp.dest('Js')); //输出 &#125;); //默认命令，在cmd中输入gulp后，执行的就是这个任务(压缩js需要在检查js之后操作) gulp.task('default',['jshint'],function() &#123; gulp.start('minifycss','minifyjs'); &#125;); 运行gulp任务cd 到指定的项目目录，运行gulp 1$ gulp","categories":[{"name":"Tools","slug":"Tools","permalink":"http://jypblue.github.io/categories/Tools/"}],"tags":[{"name":"gulp","slug":"gulp","permalink":"http://jypblue.github.io/tags/gulp/"}]},{"title":"H5开发遇到的一些坑","slug":"H5开发遇到的一些坑","date":"2016-03-16T07:05:46.000Z","updated":"2016-04-28T10:56:40.000Z","comments":true,"path":"2016/03/16/H5开发遇到的一些坑/","link":"","permalink":"http://jypblue.github.io/2016/03/16/H5开发遇到的一些坑/","excerpt":"","text":"2014年毕业进携程工作后，一开始主要做PC端的前端工作，主要的坑都是IE以及火狐的，而2015年下半年开始负责移动前端工作后，发现出来的坑就层出不穷了。我就列一下这大半年做H5开发遇到的一些坑及对应的解决方案；至于过程就不细说了，主要是通过stackoverflow,知乎，segmentfault,quora,论坛，博客等地方查询到的解决方案。之后如有新的坑会继续追加进来。 坑1.安卓UC浏览器字体放大Q: 安卓的UC浏览器会默认开启字体放大功能，具体来说就是当UC浏览器识别到你某个标签里面的文字过多的时候，它就会默认将它放大显示，这样就会带来一个问题就是你写的样式错乱了，显示不正常。 S: 在HTML中添加关闭这个功能的meta标签: 1&lt;meta name=\"wap-font-scale\" content=\"no\"&gt; 坑2.input有颜色线框Q: 在Android机型中显示input框的时候，点击选择会有蓝色线框出现。 S: 设置css样式进行重置 1-webkit-tap-highlight-color:rgba(0,0,0,0); 坑3.页面高度渲染错误Q: 这种情况最普遍的是做活动页面，需要微信微博分享的那种，因为在这些应用中都有各种导航条，占有一定的高度位置。导致你css设置的高度100%跟模拟器里面的不一致。 S: 所以我们需要重置修正它，通过javascript代码重置掉： 1document.documentElement.style.height = window.innerHeight + 'px'; 坑4.UC下flex布局行内元素不占位Q: UC浏览器在利用flex布局亦或者横向占位的时候，如果你不显示设置display:block;以及宽度等属性时候，会与chrome等其它webkit浏览器显示效果不一致。 S: 如果使用行内标签那就块级话，宽度也显示写出来就可以解决了。 坑5.flex布局内容不一致无法均分Q: 在Android机浏览器下使用flex布局，flex item 等分布局的时候，某一列的数据内容过多的时候，会把它的宽度撑宽，无法做到等分布局。 S: 在flex item 代码中加一个width:1%，保证剩余空间相同. 1.flex-1&#123;-webkit-box-flex:1;-webkit-flex:1;-ms-flex:1;flex:1;width:1%;&#125; 坑5.safari浏览器下input[type=”password”\u0010]无法输入Q: 在hybrid开发webview中，ios系统下input[password]输入框无法输入（但是键盘可以弹起,输入框无法聚焦） S: 是css全局设定-webkit-user-select:none导致。所以在input和textarea标签重新设置该属性即可： 123input,textarea &#123; -webkit-user-select: auto !important;&#125;","categories":[{"name":"FrontEnd","slug":"FrontEnd","permalink":"http://jypblue.github.io/categories/FrontEnd/"}],"tags":[{"name":"移动端","slug":"移动端","permalink":"http://jypblue.github.io/tags/移动端/"},{"name":"坑","slug":"坑","permalink":"http://jypblue.github.io/tags/坑/"}]},{"title":"Node如何连接Mongodb","slug":"Node如何连接mongodb","date":"2016-03-12T08:15:51.000Z","updated":"2016-06-21T07:46:47.000Z","comments":true,"path":"2016/03/12/Node如何连接mongodb/","link":"","permalink":"http://jypblue.github.io/2016/03/12/Node如何连接mongodb/","excerpt":"","text":"今年初开始下定决心开始学习nodejs，之前断断续续看了一些node的api，但是一直没有一个总体的认识，于是买了书查看网上教程先跟着别人的教程跑通一个web站点以此作为对node总体的一个了解，记录的第一个简单知识点就是利用mongoose这个模块连接mongodb数据库。 1.安装mongodb首先我们进入mongodb官网https://www.mongodb.org/downloads#production 选择自己需要的版本下载，然后直接点击安装即可。亦或者我们直接通过Homebrew进行安装，直接打开shell终端,运行命令行 brew install mongodb 2.启动mongodb安装完成后我们需要启动mongodb数据库才能进行连接。继续运行命令行 mongod –config /usr/local/etc/mongod.conf 3.连接mongodb连接mongodb,直接shell终端输入 mongo 就进入mongodb操作界面，就可以使用mongodb语法增删修改数据库了。另外还有一个mongodb可视化管理工具Robomongo可以使用，跨平台的。用起来还是蛮方便的。 4.利用mongoose在node项目中操纵mongodb首先我们需要下载mongoose模块，直接在你的项目文件夹下运行 npm install mongoose –save-dev 就安装好了。然后直接根据官网的demo代码来做1.引入mongoose，连接mongodb 12var mongoose = require('mongoose');mongoose.connect('mongodb://localhost/test'); 2.操作mongodb mongoose的数据模型设计为Schema、Model、Documents三者。 Schema 模式定义 1234567891011121314var mongoose = require('mongoose');var Schema = mongoose.Schema;var blogSchema = new Schema(&#123; title: String, author: String, body: String, comments: [&#123; body: String, date: Date &#125;], date: &#123; type: Date, default: Date.now &#125;, hidden: Boolean, meta: &#123; votes: Number, favs: Number &#125;&#125;); Model 编译模型 1234var mongoose = require('mongoose');var blogSchema = require('../schemas/blog');var Blog = mongoose.model('Blog', blogSchema);module.exports = Blog; Documents 文档实例化 12345678910111213141516171819var Blog = require('../models/blog);var small = new Blog(&#123; size: 'small' &#125;);//保存Blog.save(function (err) &#123; if (err) return handleError(err); // saved!&#125;)// or 增Blog.create(&#123; size: 'small' &#125;, function (err, small) &#123; if (err) return handleError(err); // saved!&#125;)//查询Blog.find(&#123; size: 'small' &#125;).where('createdDate').gt(oneYearAgo).exec(callback);//删除Blog.remove(&#123; size: 'large' &#125;, function (err) &#123; if (err) return handleError(err); // removed!&#125;); 我的理解就是Schema是组装，定义数据字段的，Model进行数据的编译转化，Documents进行数据的实例化，做到增删改查的操作。","categories":[{"name":"Node","slug":"Node","permalink":"http://jypblue.github.io/categories/Node/"}],"tags":[{"name":"Node","slug":"Node","permalink":"http://jypblue.github.io/tags/Node/"},{"name":"Mongodb","slug":"Mongodb","permalink":"http://jypblue.github.io/tags/Mongodb/"}]},{"title":"Retina屏实现1像素","slug":"Retina屏实现1像素","date":"2015-12-18T03:05:46.000Z","updated":"2016-06-27T11:37:55.000Z","comments":true,"path":"2015/12/18/Retina屏实现1像素/","link":"","permalink":"http://jypblue.github.io/2015/12/18/Retina屏实现1像素/","excerpt":"","text":"1.transform:scale(0.5)实现方式： 1234height:1px;-webkit-transform: scaleY(0.5);-webkit-transform-origin:0 0;overflow: hidden; 此方案配合:after和:before独立使用较多，比如画一个商品的边框四条线，容器的after和before可以画2条线，利用容器的父元素的after、before再画2条线。 12345678910111213.after-scale&#123; position: relative;&#125;.after-scale:after&#123; content:\"\"; position: absolute; bottom:0px; left:0px; right:0px; border-bottom:1px solid #c8c7cc; -webkit-transform:scaleY(.5); -webkit-transform-origin:0 0;&#125; 四边1像素border 12345678910111213141516.scale&#123; position:relative;&#125;.scale:before&#123; content:\"\"; position:absolute; top:0; left:0; width:200%; height:200%; border:1px solid #dadada; box-sizing:border-box; transform: scale(0.5); -webkit-transform: scale(0.5); transform-origin: 0 0; -webkit-transform-origin: 0 0;&#125; 2.box-shadow实现方式： 利用css 对阴影处理的方式实现0.5px的效果 底部一条线 1-webkit-box-shadow:0 1px 1px -1px rgba(0, 0, 0, 0.5); 顶部一条线1box-shadow: 0 -1px 1px -1px rgba(0, 0, 0, 0.5); 基本所有场景都能满足，包含圆角的button，单条，多条线;但是颜色不好处理，黑色rgba(0,0,0,1)最浓的情况了。有的浏览器会有阴影出现，不好用。 3.background-image实现方式： 设置1px通过css 实现的image，50%有颜色，50%透明 12345678910.border &#123; background-image:linear-gradient(180deg, red, red 50%, transparent 50%), linear-gradient(270deg, red, red 50%, transparent 50%), linear-gradient(0deg, red, red 50%, transparent 50%), linear-gradient(90deg, red, red 50%, transparent 50%); background-size: 100% 1px,1px 100% ,100% 1px, 1px 100%; background-repeat: no-repeat; background-position: top, right top, bottom, left top; padding: 10px; &#125; 配合background-image,background-size,background-position可以实现单条、多条边框，边框的颜色随意设置;但如果有圆角的效果，很sorry圆角的地方没有线框的颜色，且要写的代码也不少。 4.用图片实现方式： 1234.border-image&#123; border-image:url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAAECAYAAABP2FU6AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAB5JREFUeNpiPnH8zH/G////MzAxAAHTyRNn/wMEGABpvQm9g9TJ1QAAAABJRU5ErkJggg==\") 2 0 stretch; border-width: 0px 0px 1px;&#125; 可以通过修改图片来达到圆角的效果，但是由于图片的原因，压缩过后的图片边缘变模糊了（不放大的情况下不明显），需要引用图片或者base64，边框颜色修改起来不方便。 参考：http://stackoverflow.com/questions/8640521/can-you-have-a-0-5px-border-on-a-retina-display/25910251#25910251 实际运用中，我会用box-shadow实现矩形四边线框一像素，而用transform搭配before、after伪类的形式实现单独一边的一像素。目前来看，可以适用绝大部分业务场景。","categories":[{"name":"FrontEnd","slug":"FrontEnd","permalink":"http://jypblue.github.io/categories/FrontEnd/"}],"tags":[{"name":"Css","slug":"Css","permalink":"http://jypblue.github.io/tags/Css/"}]},{"title":"如何在浏览器实现高斯模糊","slug":"如何在浏览器上实现高斯模糊效果","date":"2015-12-18T03:05:46.000Z","updated":"2016-06-27T11:41:25.000Z","comments":true,"path":"2015/12/18/如何在浏览器上实现高斯模糊效果/","link":"","permalink":"http://jypblue.github.io/2015/12/18/如何在浏览器上实现高斯模糊效果/","excerpt":"","text":"1.css实现高斯模糊css3 blur滤镜实现css代码如下： 123456.blur&#123; -webkit-filter: blur(4px); /* Chrome, Opera */ -moz-filter: blur(4px); -ms-filter: blur(4px); filter: blur(4px); &#125; 但是仅这样做，在浏览器显示会出现白边的问题，如下图： 所以需要在此基础上添加没有blur样式图片盖掉白边： 12&lt;img src=\"blur1\"/&gt;&lt;img src=\"blur1\" class=\"blur\"/&gt; 这样显示就正常了： 如果需要在PC端实现高斯模糊效果，则需要兼容IE及Firefox等浏览器，则只需添加IE filter滤镜和svg文件就好了： 12345678 .blur&#123; filter: url(blur.svg#blur); /* FireFox, Chrome, Opera */ -webkit-filter: blur(10px); /* Chrome, Opera */ -moz-filter: blur(10px); -ms-filter: blur(10px); filter: blur(10px);filter: progid:DXImageTransform.Microsoft.Blur(PixelRadius=10, MakeShadow=false); /* IE6~IE9 */ &#125; 至此利用css实现了兼容性较好的高斯模糊效果。 注：android下UC浏览器不支持css3属性filter 2.canvas实现高斯模糊利用StackBlur.js库实现该js库的demo地址：http://www.quasimondo.com/StackBlurForCanvas/StackBlurDemo.html 该方法可以实现图片的高斯模糊效果，不依赖其他任何JS框架，一般用法如下： 1stackBlurImage( sourceImageID, targetCanvasID, radius, blurAlphaChannel ); 其中： sourceImageID表示要模糊的图片的id, 默认这个图片要隐藏； targetCanvasID表示要显示模糊图片的canvas元素的id; radius表示模糊的半径大小。不过，根据我的对比测试，radius好像与CSS中filter滤镜的模糊值不是1:1匹配的，反倒是有些类似2:1. 也就是这里的20px的半径模糊近似于CSS中blur滤镜值设置为10px; blurAlphaChannel为布尔属性，表示aplha透明通道是否要模糊，true表示要模糊。 CSS代码： 1234567.blur &#123; filter: progid:DXImageTransform.Microsoft.Blur(PixelRadius=10, MakeShadow=false); /* IE6~IE9 */&#125;:root .blur &#123; display: none; /* IE9+, Firefox, Chrome, Opera - hidden */ filter: none; /* no IE9 */&#125; HTML代码： 123&lt;img src=\"blur1.jpg\" /&gt;&lt;img src=\"blur1.jpg\" id=\"blur\" class=\"blur\" /&gt;&lt;canvas id=\"canvas\" width=\"463\" height=\"291\"&gt;&lt;/canvas&gt; JS代码： 1stackBlurImage( \"blur\", \"canvas\", 20, false ); 以上在pc浏览器也实现了兼容性较好的高斯模糊效果。 高斯模糊效果我主要还是应用在移动端，所以只使用了css3的写法就基本可以实现毛玻璃的模糊效果，满足需求。","categories":[{"name":"FrontEnd","slug":"FrontEnd","permalink":"http://jypblue.github.io/categories/FrontEnd/"}],"tags":[{"name":"Css","slug":"Css","permalink":"http://jypblue.github.io/tags/Css/"}]},{"title":"移动布局知识要点","slug":"移动布局知识要点","date":"2015-12-18T03:05:46.000Z","updated":"2016-06-27T11:38:52.000Z","comments":true,"path":"2015/12/18/移动布局知识要点/","link":"","permalink":"http://jypblue.github.io/2015/12/18/移动布局知识要点/","excerpt":"","text":"1.meta基础知识H5页面窗口自动调整到设备宽度，并禁止用户缩放页面1&lt;meta name=\"viewport\" content=\"width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no\" /&gt; 删除苹果默认的工具栏和菜单栏1&lt;meta name=\"apple-mobile-web-app-capable\" content=\"yes\" /&gt; 设置苹果工具栏颜色1&lt;meta name=\"apple-mobile-web-app-status-bar-style\" content=\"black\" /&gt; 忽略页面中的数字识别为电话，忽略email识别1&lt;meta name=\"format-detection\" content=\"telphone=no, email=no\" /&gt; 启用360浏览器的极速模式(webkit)1&lt;meta name=\"renderer\" content=\"webkit\"&gt; 避免IE使用兼容模式1&lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt; 针对手持设备优化，主要是针对一些老的不识别viewport的浏览器，比如黑莓1&lt;meta name=\"HandheldFriendly\" content=\"true\"&gt; 微软的老式浏览器1&lt;meta name=\"MobileOptimized\" content=\"320\"&gt; uc强制竖屏1&lt;meta name=\"screen-orientation\" content=\"portrait\"&gt; QQ强制竖屏1&lt;meta name=\"x5-orientation\" content=\"portrait\"&gt; UC强制全屏1&lt;meta name=\"full-screen\" content=\"yes\"&gt; QQ强制全屏1&lt;meta name=\"x5-fullscreen\" content=\"true\"&gt; UC应用模式1&lt;meta name=\"browsermode\" content=\"application\"&gt; UC关闭文字放大1&lt;meta name=\"wap-font-scale\" content=\"no\"&gt; QQ应用模式1&lt;meta name=\"x5-page-mode\" content=\"app\"&gt; windows phone 点击无高光1&lt;meta name=\"msapplication-tap-highlight\" content=\"no\"&gt; 2.屏幕旋转样式及事件样式这是匹配横屏的状态，横屏时的css代码: 123@media screen and (orientation:landscape)&#123; .css&#123;&#125;&#125; 这是匹配竖屏的状态，竖屏时的css代码: 123@media screen and (orientation:portrait)&#123; .css&#123;&#125;&#125; 事件window.orientation，取值：正负90表示横屏模式、0和180表现为竖屏模式；1234567891011window.onorientationchange = function()&#123; switch(window.orientation)&#123; case -90: case 90: alert(\"横屏:\" + window.orientation); case 0: case 180: alert(\"竖屏:\" + window.orientation); break; &#125;&#125; 3.总体布局方案px+百分比这种布局方案之前比较多，设计稿设计的时候选择一个比较折中的尺寸，例如iPhone6，字体大小比iPhone5大一点，比iPhone6小一点，字体用px写死，宽度按百分比缩放，高度写死。这样的话就是大部分机型都可以看，但是问题是如果大屏手机看就会偏小，怎么解决了？就是再利用css属性 1@media screen and (min-width:w) and (max-width:w) 再来给某些类做单独的适配。 淘宝方案：rem+media screen + viewport缩放jsviewport缩放js12345678910111213141516171819202122232425262728var dpr,rem,scale;var docEl = document.documentElement;var fontEl = document.createElement('style');var metaEl = document.querySelector('meta[name=\"viewport\"]');var uA = window.navigator.userAgent;dpr = window.devicePixelRatio || 1;scale = 1 / dpr;//最大宽度是540px,rem = (docEl.clientWidth &gt; 540 ? 540 : docEl.clientWidth) * dpr * 0.625 / 10;//设置viewport, 进行缩放，达到高清效果metaEl.setAttribute('content','width=' + dpr*docEl.clientWidth + ',initial-scale=' + scale +',minimum-scale='+scale + ',maximum-scale=' + scale + ',user-scalable=no');//设置data-dpr属性，留作的css hack 之用docEl.setAttribute('data-dpr',dpr);docEl.setAttribute('style','font-size:'+rem+'px;');//动态写入样式docEl.firstElementChild.appendChild(fontEl);//fontEl.innerHTML = 'html&#123;font-size:'+rem+'px!important;&#125;';window.rem2px = function(v) &#123;v = parseFloat(v);return v * rem;&#125;window.px2rem = function(v) &#123;v = parseFloat(v);return v / rem;&#125;window.dpr = dpr;window.rem = rem; 设置了rem以及viewport的缩放比例后，通过sass脚本编写适配dpr为1倍，2倍，3倍的css样式，布局用rem布局，字体用px，而不同宽度字体大小也是通过 1234567891011121314151617181920212223242526272829303132333435@media screen and (min-width:480px) and (max-width:639px) &#123; html &#123; font-size: 15px &#125;&#125;@media screen and (min-width:640px) and (max-width:719px) &#123; html &#123; font-size: 20px &#125;&#125;@media screen and (min-width:720px) and (max-width:749px) &#123; html &#123; font-size: 22.5px &#125;&#125;@media screen and (min-width:750px) and (max-width:799px) &#123; html &#123; font-size: 23.5px &#125;&#125;@media screen and (min-width:800px) and (max-width:959px) &#123; html &#123; font-size: 25px &#125;&#125;@media screen and (min-width:960px) and (max-width:1079px) &#123; html &#123; font-size: 30px &#125;&#125;@media screen and (min-width:1080px) &#123; html &#123; font-size: 32px &#125;&#125; 来实现适配; rem+js动态控制基准值这种方式是在html加载样式之前，给html标签设置rem的基准值，通过不同宽度设置不同的基准值再用rem布局做到等比缩放布局的，一般以320px的宽度为最小宽度设置，至于这个基准值放大比例，可以按自己的需求来定。所有布局都用rem来布局，对于没有非矢量字体，以及对字体大小精细度要求没那么严格的项目来讲十分合适。相较前面而言简单很多。css适配代码也少写很多。js脚本如下： 123456789101112131415161718192021(function (root) &#123; var docEl = document.documentElement, timer = null, width,last; function changeRem() &#123; width = docEl.getBoundingClientRect().width; if(last === width) &#123;return;&#125; last = width; root.rem = width/20; docEl.style.fontSize = root.rem + 'px'; &#125; changeRem(); root.addEventListener('resize',function() &#123; clearTimeout(timer); timer = setTimeout(changeRem,200); &#125;); root.addEventListener('orientationchange',function() &#123; clearTimeout(timer); timer = setTimeout(changeRem,200); &#125;);&#125;)(window,undefined); 4.flex布局flex布局目前可使用在移动中，并非所有的语法都全兼容123456789101112131415/* ============================================================ flex：定义布局为盒模型 flex-v：盒模型垂直布局 flex-1：子元素占据剩余的空间 flex-align-center：子元素垂直居中 flex-pack-center：子元素水平居中 flex-pack-justify：子元素两端对齐 兼容性：ios 4+、android 2.3+、winphone8+ ============================================================ */.flex&#123;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;&#125;.flex-v&#123;-webkit-box-orient:vertical;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;&#125;.flex-1&#123;-webkit-box-flex:1;-webkit-flex:1;-ms-flex:1;flex:1;&#125;.flex-align-center&#123;-webkit-box-align:center;-webkit-align-items:center;-ms-flex-align:center;align-items:center;&#125;.flex-pack-center&#123;-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center;&#125;.flex-pack-justify&#123;-webkit-box-pack:justify;-webkit-justify-content:space-between;-ms-flex-pack:justify;justify-content:space-between;&#125; 5.常见问题移动端touch事件(区分webkit 和 winphone)当用户手指放在移动设备在屏幕上滑动会触发的touch事件 以下支持webkit touchstart——当手指触碰屏幕时候发生。不管当前有多少只手指 touchmove——当手指在屏幕上滑动时连续触发。通常我们再滑屏页面，会调用event的preventDefault()可以阻止默认情况的发生：阻止页面滚动 touchend——当手指离开屏幕时触发 touchcancel——系统停止跟踪触摸时候会触发。例如在触摸过程中突然页面alert()一个提示框，此时会触发该事件，这个事件比较少用 以下支持winphone 8 MSPointerDown——当手指触碰屏幕时候发生。不管当前有多少只手指 MSPointerMove——当手指在屏幕上滑动时连续触发。通常我们再滑屏页面，会调用css的html{-ms-touch-action: none;}可以阻止默认情况的发生：阻止页面滚动 MSPointerUp——当手指离开屏幕时触发 移动端click屏幕产生200-300 ms的延迟响应移动设备上的web网页是有300ms延迟的，玩玩会造成按钮点击延迟甚至是点击失效。 以下是历史原因，来源其他人的分享： 2007年苹果发布首款iphone上IOS系统搭载的safari为了将适用于PC端上大屏幕的网页能比较好的展示在手机端上，使用了双击缩放(double tap to zoom)的方案，比如你在手机上用浏览器打开一个PC上的网页，你可能在看到页面内容虽然可以撑满整个屏幕，但是字体、图片都很小看不清，此时可以快速双击屏幕上的某一部分，你就能看清该部分放大后的内容，再次双击后能回到原始状态。 双击缩放是指用手指在屏幕上快速点击两次，iOS 自带的 Safari 浏览器会将网页缩放至原始比例。 原因就出在浏览器需要如何判断快速点击上，当用户在屏幕上单击某一个元素时候，例如跳转链接，此处浏览器会先捕获该次单击，但浏览器不能决定用户是单纯要点击链接还是要双击该部分区域进行缩放操作，所以，捕获第一次单击后，浏览器会先Hold一段时间t，如果在t时间区间里用户未进行下一次点击，则浏览器会做单击跳转链接的处理，如果t时间里用户进行了第二次单击操作，则浏览器会禁止跳转，转而进行对该部分区域页面的缩放操作。那么这个时间区间t有多少呢？在IOS safari下，大概为300毫秒。这就是延迟的由来。造成的后果用户纯粹单击页面，页面需要过一段时间才响应，给用户慢体验感觉，对于web开发者来说是，页面js捕获click事件的回调函数处理，需要300ms后才生效，也就间接导致影响其他业务逻辑的处理。 解决方案： fastclick可以解决在手机上点击事件的300ms延迟zepto的touch模块，tap事件也是为了解决在click的延迟问题 触摸事件的响应顺序1、ontouchstart2、ontouchmove3、ontouchend4、onclick 解决300ms延迟的问题，也可以通过绑定ontouchstart事件，加快对事件的响应 什么是Retina 显示屏，带来了什么问题retina：一种具备超高像素密度的液晶屏，同样大小的屏幕上显示的像素点由1个变为多个，如在同样带下的屏幕上，苹果设备的retina显示屏中，像素点1个变为4个 在高清显示屏中的位图被放大，图片会变得模糊，因此移动端的视觉稿通常会设计为传统PC的2倍 那么，前端的应对方案是： 设计稿切出来的图片长宽保证为偶数，并使用backgroud-size把图片缩小为原来的1/2 //例如图片宽高为：200px*200px，那么写法如下 1.css&#123;width:100px;height:100px;background-size:100px 100px;&#125; 其它元素的取值为原来的1/2，例如视觉稿40px的字体，使用样式的写法为20px 1.css&#123;font-size:20px&#125; Retina屏实现真·1像素的的方法：参考《Retina屏实现1像素》ios系统中元素被触摸时产生的半透明灰色遮罩怎么去掉ios用户点击一个链接，会出现一个半透明灰色遮罩, 如果想要禁用，可设置-webkit-tap-highlight-color的alpha值为0，也就是属性值的最后一位设置为0就可以去除半透明灰色遮罩 1a,button,input,textarea&#123;-webkit-tap-highlight-color: rgba(0,0,0,0;)&#125; 部分android系统中元素被点击时产生的边框怎么去掉android用户点击一个链接，会出现一个边框或者半透明灰色遮罩, 不同生产商定义出来额效果不一样，可设置-webkit-tap-highlight-color的alpha值为0去除部分机器自带的效果 1234a,button,input,textarea&#123;-webkit-tap-highlight-color: rgba(0,0,0,0;)-webkit-user-modify:read-write-plaintext-only;&#125; -webkit-user-modify有个副作用，就是输入法不再能够输入多个字符 另外，有些机型去除不了，如小米2 对于按钮类还有个办法，不使用a或者input标签，直接用div标签 winphone系统a、input标签被点击时产生的半透明灰色背景怎么去掉1&lt;meta name=\"msapplication-tap-highlight\" content=\"no\"&gt; webkit表单元素的默认外观怎么重置1.css&#123;-webkit-appearance:none;&#125; webkit表单输入框placeholder的颜色值能改变么12input::-webkit-input-placeholder&#123;color:#AAAAAA;&#125;input:focus::-webkit-input-placeholder&#123;color:#EEEEEE;&#125; webkit表单输入框placeholder的文字能换行么ios可以，android不行~ IE10（winphone8）表单元素默认外观如何重置禁用 select 默认下拉箭头 ::-ms-expand 适用于表单选择控件下拉箭头的修改，有多个属性值，设置它隐藏 (display:none) 并使用背景图片来修饰可得到我们想要的效果。 123select::-ms-expand &#123;display: none;&#125; 禁用 radio 和 checkbox 默认样式 ::-ms-check 适用于表单复选框或单选按钮默认图标的修改，同样有多个属性值，设置它隐藏 (display:none) 并使用背景图片来修饰可得到我们想要的效果。 123input[type=radio]::-ms-check,input[type=checkbox]::-ms-check&#123;display: none;&#125; 禁用PC端表单输入框默认清除按钮 当表单文本输入框输入内容后会显示文本清除按钮，::-ms-clear 适用于该清除按钮的修改，同样设置使它隐藏 (display:none) 并使用背景图片来修饰可得到我们想要的效果。 123input[type=text]::-ms-clear,input[type=tel]::-ms-clear,input[type=number]::-ms-clear&#123;display: none;&#125; 禁止ios长按时不触发系统的菜单，禁止ios&amp;android长按时下载图片1.css&#123;-webkit-touch-callout: none&#125; 禁止ios和android用户选中文字1.css&#123;-webkit-user-select:none&#125; 打电话发短信的怎么实现打电话 1&lt;a href=\"tel:0755-10086\"&gt;打电话给:0755-10086&lt;/a&gt; 发短信，winphone系统无效 1&lt;a href=\"sms:10086\"&gt;发短信给: 10086&lt;/a&gt; audio元素和video元素在ios和andriod中无法自动播放应对方案：触屏即播 123$('html').one('touchstart',function()&#123; audio.play()&#125;) 摇一摇功能HTML5 deviceMotion：封装了运动传感器数据的事件，可以获取手机运动状态下的运动加速度等数据。 微信浏览器用户调整字体大小后页面矬了，怎么阻止用户调整原因 android侧是复写了layoutinflater 对textview做了统一处理ios侧是修改了body.style.webkitTextSizeAdjust值普通解决方案： android暂无方案ios使用-webkit-text-size-adjust禁止调整字体大小 1body&#123;-webkit-text-size-adjust: 100%!important;&#125; 最好的解决方案： 整个页面用rem或者百分比布局 消除transition闪屏网络都是这么写的，但我并没有测试出来 123456.css&#123;//设置内嵌的元素在 3D 空间如何呈现：保留 3D-webkit-transform-style: preserve-3d;//（设置进行转换的元素的背面在面对用户时是否可见：隐藏）-webkit-backface-visibility: hidden;&#125; 开启硬件加速解决页面闪白保证动画流畅 123456.css &#123; -webkit-transform: translate3d(0, 0, 0); -moz-transform: translate3d(0, 0, 0); -ms-transform: translate3d(0, 0, 0); transform: translate3d(0, 0, 0);&#125; 取消input在ios下，输入的时候英文首字母的默认大写1&lt;input autocapitalize=\"off\" autocorrect=\"off\" /&gt; android 上去掉语音输入按钮1input::-webkit-input-speech-button &#123;display: none&#125; android 2.3 bug@-webkit-keyframes 需要以0%开始100%结束，0%的百分号不能去掉after和before伪类无法使用动画border-radius不支持%单位translate百分比的写法和scale在一起会导致失效，例如-webkit-transform: translate(-50%,-50%) scale(-0.5, 1) android 4.x bug三星 Galaxy S4中自带浏览器不支持border-radius缩写同时设置border-radius和背景色的时候，背景色会溢出到圆角以外部分部分手机(如三星)，a链接支持鼠标:visited事件，也就是说链接访问后文字变为紫色 设计高性能CSS3动画的几个要素尽可能地使用合成属性transform和opacity来设计CSS3动画，不使用position的left和top来定位利用translate3D开启GPU加速 fixed bugios下fixed元素容易定位出错，软键盘弹出时，影响fixed元素定位android下fixed表现要比iOS更好，软键盘弹出时，不会影响fixed元素定位ios4下不支持position:fixed解决方案 可用isroll.js，暂无完美方案 6.常用的移动端框架zepto.js语法与jquery几乎一样，会jquery基本会zepto~ 最新版本已经更新到1.16 官网：http://zeptojs.com/ 中文(非官网)：http://www.css88.com/doc/zeptojs_api/ 常使用的扩展模块：浏览器检测：https://github.com/madrobby/zepto/blob/master/src/detect.js tap事件：https://github.com/madrobby/zepto/blob/master/src/touch.js iscroll.js解决页面不支持弹性滚动，不支持fixed引起的问题~ 实现下拉刷新，滑屏，缩放等功能~ 最新版本已经更新到5.0 官网：http://cubiq.org/iscroll-5 underscore.js笔者没用过，不过听说好用，推荐给大家~ 该库提供了一整套函数式编程的实用功能，但是没有扩展任何JavaScript内置对象。 最新版本已经更新到1.8.2 官网：http://underscorejs.org/ 滑屏框架适合上下滑屏、左右滑屏等滑屏切换页面的效果 slip.js iSlider.js fullpage.js","categories":[{"name":"FrontEnd","slug":"FrontEnd","permalink":"http://jypblue.github.io/categories/FrontEnd/"}],"tags":[{"name":"Css","slug":"Css","permalink":"http://jypblue.github.io/tags/Css/"},{"name":"Js","slug":"Js","permalink":"http://jypblue.github.io/tags/Js/"},{"name":"移动开发","slug":"移动开发","permalink":"http://jypblue.github.io/tags/移动开发/"}]}]}