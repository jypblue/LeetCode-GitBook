# 3. Longest Substring Without Repeating Characters
##### Tags
1. String
2. Hash Table
3. Two Pointers

>Given a string, find the length of the <strong>longest substring</strong> without repeating characters.
>
><strong>Examples:</strong>
>
>Given `"abcabcbb"`, the answer is `"abc"`, which the length is 3.
>
>Given `"bbbbb"`, the answer is `"b"`, with the length of 1.
>
>Given `"pwwkew"`, the answer is `"wke"`, with the length of 3. Note that the answer must be a substring, `"pwke"` is a subsequence and not a substring.

##### 题意：
给定一个字符串，寻找字符串中不重复最长子串的长度

##### 分析：
分析题目，抓住两个关键词：
1. 最长子串 =>寻找子串起点和终点位置
2. 不重复 =>循环比较字符是否重复

##### 思路：
由此，第一个想法就是逐个字符比对，暴力搜索。但是如果完全循环的话，时间复杂度太高，将达到O(n<sup>3</sup>);肯定会出现Time Limit Exceeded。因此想到了做改良。思路如下：
1. 将字符串第i位与其之前的每位字符一一比较
2. 如果不相等，记录两者位置距离长度
3. 如果相等，退出，返回之前记录的距离长度
4. 注意一开始就重复的特殊情况‘aa’

##### Js实现
方法1是自己的实现，后面几个方法都是谷歌后实现的
##### 方法 #1 暴力搜索
##### 时间复杂度
 <= O(n<sup>2</sup>) && >= O(n)

```
let lengthOfLongestSubstring = function(s) {
  let index = 0;
  let maxstr = 0;
  let len = s.length;
  if (len === 0 || s === null) return 0;
  if (len === 1) return 1;
  for (let i = 1; i < len; i++) {
    for (let j = i - 1; j >= index; j--) {
      if (s[i] === s[j]) {
        index = j + 1;
        if (i == 1) {
          maxstr = 1;
        }
        break;
      } else {
        if (maxstr < i - j + 1)
          maxstr = i - j + 1;
      }
    }
  }
  return maxstr;
};
```

##### 方法 #2 滑动窗口
##### 时间复杂度
O(n<sup>2</sup>)

```
let lengthOfLongestSubstring = function(s) {
   if (s === null || s.length === 0) {
          return 0;
      }
      let set = new Set();
      let leftBound = 0, max = 0;
      for (let i = 0; i < s.length; i++) {
          if (set.has(s.charAt(i))) {
              while (leftBound < i && s.charAt(leftBound) != s.charAt(i)) {
                  set.delete(s.charAt(leftBound));
                  leftBound ++;
              }
              leftBound ++;
          } else {
              set.add(s.charAt(i));
              max = Math.max(max, i - leftBound + 1);
          }
      }
      return max;
}
```











