# 3. Longest Substring Without Repeating Characters
##### Tags
1. String
2. Hash Table
3. Two Pointers

>Given a string, find the length of the <strong>longest substring</strong> without repeating characters.
>
><strong>Examples:</strong>
>
>Given `"abcabcbb"`, the answer is `"abc"`, which the length is 3.
>
>Given `"bbbbb"`, the answer is `"b"`, with the length of 1.
>
>Given `"pwwkew"`, the answer is `"wke"`, with the length of 3. Note that the answer must be a substring, `"pwke"` is a subsequence and not a substring.

##### 题意：
给定一个字符串，寻找字符串中不重复最长子串的长度

##### 分析：
分析题目，抓住两个关键词：
1. 最长子串 =>寻找子串起点和终点位置
2. 不重复 =>循环比较字符是否重复

##### 思路：
由此，第一个想法就是逐个字符比对，暴力搜索。但是如果完全循环的话，时间复杂度太高，将达到O(n<sup>3</sup>);肯定会出现Time Limit Exceeded。因此想到了做改良。思路如下：
1. 将字符串第i位与其之前的每位字符一一比较
2. 如果不相等，记录两者位置距离长度
3. 如果相等，退出，返回之前记录的距离长度
4. 注意一开始就重复的特殊情况‘aa’

##### Js实现
方法1是自己的实现，后面几个方法都是谷歌后使用JavaScript实现的
##### 方法 #1 暴力搜索
##### 时间复杂度
 <= O(n<sup>2</sup>) && >= O(n)

```
let lengthOfLongestSubstring = function(s) {
  let index = 0;
  let maxstr = 0;
  let len = s.length;
  if (len === 0 || s === null) return 0;
  if (len === 1) return 1;
  for (let i = 1; i < len; i++) {
    for (let j = i - 1; j >= index; j--) {
      if (s[i] === s[j]) {
        index = j + 1;
        if (i == 1) {
          maxstr = 1;
        }
        break;
      } else {
        if (maxstr < i - j + 1)
          maxstr = i - j + 1;
      }
    }
  }
  return maxstr;
};
```

##### 方法 #2 
##### 时间复杂度
O(n<sup>2</sup>)

```
let lengthOfLongestSubstring = function(s) {
   if (s === null || s.length === 0) {
          return 0;
      }
      let set = new Set();
      let leftBound = 0, max = 0;
      for (let i = 0; i < s.length; i++) {
          if (set.has(s.charAt(i))) {
              while (leftBound < i && s.charAt(leftBound) != s.charAt(i)) {
                  set.delete(s.charAt(leftBound));
                  leftBound ++;
              }
              leftBound ++;
          } else {
              set.add(s.charAt(i));
              max = Math.max(max, i - leftBound + 1);
          }
      }
      return max;
}
```

##### 方法 #3 扩展的ASCII码 Map存储

```
let lengthOfLongestSubstring = function(s) {
        let map = new Map(); // map from character's ASCII to its last occured index
        let ans = 0;
        let slow = 0;

        for(let i =0;i<256;i++) map.set(i,-1);

        for (let fast = 0; fast < s.length; fast++) {
            let ch = s.charAt(fast);
            if (map.get(ch) >= slow) {
                ans = Math.max(ans, fast - slow);
                slow = map.get(ch) + 1;
            }
            map.set(ch,fast);
        }

        return Math.max(ans, s.length - slow);
    }
```

##### 方法 #4 扩展的ASCII码 Table数组存储

```
let lengthOfLongestSubstring = function(s) {
    let start = 0; // current start point of substring without dup
    let maxlen = 0; // max length of substring found
    let table= new Array(256); // hash table for index of each char appeared
    for (let i = 0;i < 256;i++) table[i] = -1; // if char not present, index is -1
    let len = s.length;
    for (let i = 0;i < len;i++) {
        //console.log(table[s[i]]);
        if (table[s[i]] != -1) {
            while (start <= table[s[i]]) table[s[start++]] = -1;
        }
        if (i - start + 1 > maxlen) maxlen = i - start + 1;
        table[s[i]] = i;
    }
    return maxlen;
}
```








